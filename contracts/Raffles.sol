pragma solidity ^0.4.17;

import "./Players.sol";
import "./Ownership.sol";


contract Raffles is Players, Ownership {

    //Also used as nonce
    uint public length = 0;

    struct Raffle {
        bytes32 id;
        bytes32 next;
        bool exists;
        bool finished;
        uint price; //10000000000000000 Wei are 0.01 Eth, currently around 10$
        uint startsAt;
        uint endsAt;
        uint lastTicketNumber;

        uint winnerTicket;
        address winnerPlayer;

        mapping (uint => address) ticketOwner;
        mapping (address => uint[]) playerTicketsNumbers;
    }

    //Linked list of Raffle
    bytes32 public head;
    mapping (bytes32 => Raffle) public raffles;


    function isActiveRaffle(bytes32 _raffleId) public view returns(bool) {
        return (raffles[_raffleId].exists) && (raffles[_raffleId].endsAt >= now);
    }


    function playingTimeHasExpired(bytes32 _raffleId) public view returns(bool) {
        return (raffles[_raffleId].exists) &&
               (raffles[_raffleId].endsAt <= now) &&
               (raffles[_raffleId].finished == false);
    }


    function isBettingRafflePrice(bytes32 _raffleId)
        public view returns(bool rightPrice)
    {
        rightPrice = (msg.value == raffles[_raffleId].price);
    }


    function create(uint _price, uint _lifespan) public returns(bool){
        Raffle memory raffle = Raffle(0,head,true,false,_price,now,now + _lifespan,0,0,0);

        bytes32 id = keccak256(raffle.price,now,length);
        raffles[id] = raffle;

        //raffle = raffles[id];
        //raffle.id = id;
        raffles[id].id = id;

        head = id;
        length = length + 1;
    }

    //Struct autogenerated Getter() doesn't retrieve mappings,
    //so I have to create special getters
    function ownerByTicket(bytes32 _raffleAddress, uint _ticketNumber)
        public view returns(address owner)
    {
        owner = raffles[_raffleAddress].ticketOwner[_ticketNumber];
    }

    //Struct autogenerated Getter() doesn't retrieve mappings,
    //so I have to create special getters
    //ONLY EXTERNAL FUNCTIONS can return a dynamic array
    function ticketsByOwner(bytes32 _raffleAddress, address _ownerAddress)
        external view returns(uint[] tickets)
    {
        tickets = raffles[_raffleAddress].playerTicketsNumbers[_ownerAddress];
    }


    function play(bytes32 _raffleId) public payable {
        //Check the Player exists
        require(isRegistered(msg.sender));

        //Check the Raffle exists and is not finished
        require(isActiveRaffle(_raffleId));

        require(isBettingRafflePrice(_raffleId));

        uint nextTicketNumber = raffles[_raffleId].lastTicketNumber + 1;

        raffles[_raffleId].ticketOwner[nextTicketNumber] = msg.sender;
        raffles[_raffleId].playerTicketsNumbers[msg.sender].push(nextTicketNumber);
        raffles[_raffleId].lastTicketNumber = nextTicketNumber;

        //Add raffle to player's raffles list
        players[msg.sender].raffles.push(_raffleId);
    }

    //This function has to be called manually by one of the owners
    //once they know lifespan has expired. It's impossible to make the contract to call
    //this function itself. Only possible making use of external API as:
    //Ethereum Alarm Clock - http://www.ethereum-alarm-clock.com/
    //They'll call the function for you when scheduled.
    function getWinner(bytes32 _raffleId)
        external isOwner(msg.sender)
        returns(uint ticketNumber, address playerAddress, bytes32 name)
    {
        //Check the Raffle exists, playing time has expired but there has not finished
        require(isFinishedRaffle(_raffleId));

        ticketNumber = getWinnerNumber(_raffleId);

        (playerAddress, name) = getWinnerPlayer(_raffleId, ticketNumber);

        finishRaffle(_raffleId, ticketNumber, playerAddress);
    }


    //Is not possible to get a random number in a deterministic network, so this way
    //is not safe. Only way is to call to an external API Oracle to calculate it.
    function getWinnerNumber(bytes32 _raffleId)
        private view returns(uint number)
    {
        //It's not a safe way, blockhash can be changed by miner in order to make
        //its ticket number winner
        number = uint(block.blockhash(block.number - 1))%raffles[_raffleId].lastTicketNumber + 1;
    }


    function getWinnerPlayer(bytes32 _raffleId, uint _ticketNumber)
        private view returns(address player, bytes32 name)
    {
        player = ownerByTicket(_raffleId, _ticketNumber);
        name = players[player].name;
    }


    function finishRaffle(bytes32 _raffleId, uint _ticketNumber, address _playerAddress)
        internal
    {
        raffles[_raffleId].winnerTicket = _ticketNumber;
        raffles[_raffleId].winnerPlayer = _playerAddress;
        raffles[_raffleId].finished = true;
    }


    function withdrawPrize() external {

    }


    //    function destroy(uint _index) private{
//
//    }

}

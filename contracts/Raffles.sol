pragma solidity ^0.4.17;

import "./Players.sol";
import "./Ownership.sol";


contract Raffles is Players, Ownership {

    uint heldBalance = 0;

    //Also used as nonce
    uint public length = 0;

    struct Raffle {
        bytes32 id;
        bytes32 next;
        bool exists;
        bool finished;
        uint price; //10000000000000000 Wei are 0.01 Eth, currently around 10$
        uint startsAt;
        uint endsAt;
        uint lastTicketNumber;

        uint winnerTicket;
        address winnerPlayer;

        mapping (uint => address) ticketOwner;
        mapping (address => uint[]) playerTicketsNumbers;
    }

    //Linked list of Raffle
    bytes32 public head;
    mapping (bytes32 => Raffle) public raffles;


    function isActiveRaffle(bytes32 _raffleId)
        public view returns(bool)
    {
        return (raffles[_raffleId].exists) && (raffles[_raffleId].endsAt >= now);
    }


    function playingTimeHasExpired(bytes32 _raffleId)
        public view returns(bool)
    {
        return (raffles[_raffleId].exists) &&
               (raffles[_raffleId].endsAt <= now) &&
               (raffles[_raffleId].finished == false);
    }


    function isBettingRafflePrice(bytes32 _raffleId, address _playerAddress)
        public view returns(bool)
    {
        uint rafflePrice = raffles[_raffleId].price;
        Player memory player = players[_playerAddress];

        return (msg.value == rafflePrice) || (player.pendingWithdrawals >= rafflePrice);
    }

    function hasEnoughFunds(address _playerAddress, uint _amount)
        public view returns(bool)
    {
        return players[_playerAddress].pendingWithdrawals >= _amount;
    }

    function hasEnoughAvailableBalance(uint _amount)
        public view returns(bool)
    {
        return _amount <= (this.balance - heldBalance);
    }


    //===============================================================================


    //Doesn't make sense to return a value from a function that modifies the contract
    //state (transactions) because you have to wait until it is processed, something
    //that might be never happen.
    function create(uint _price, uint _lifespan)
        public returns(bytes32)
    {
        Raffle memory raffle = Raffle(0,head,true,false,_price,now,now + _lifespan,0,0,0);

        bytes32 id = keccak256(raffle.price,now,length);
        raffles[id] = raffle;

        //raffle = raffles[id];
        //raffle.id = id;
        raffles[id].id = id;

        head = id;
        length = length + 1;

        return id;
    }

    //Struct autogenerated Getter() doesn't retrieve mappings,
    //so I have to create special getters
    function ownerByTicket(bytes32 _raffleAddress, uint _ticketNumber)
        public view returns(address owner)
    {
        owner = raffles[_raffleAddress].ticketOwner[_ticketNumber];
    }

    //Struct autogenerated Getter() doesn't retrieve mappings,
    //so I have to create special getters
    //ONLY EXTERNAL FUNCTIONS can return a dynamic array
    function ticketsByOwner(bytes32 _raffleAddress, address _ownerAddress)
        external view returns(uint[] tickets)
    {
        tickets = raffles[_raffleAddress].playerTicketsNumbers[_ownerAddress];
    }


    function play(bytes32 _raffleId)
        public payable
    {
        //Check the Player exists
        require(isRegistered(msg.sender));

        //Check the Raffle exists and is not finished
        require(isActiveRaffle(_raffleId));

        require(isBettingRafflePrice(_raffleId, msg.sender));

        //Player can bet with his pending withdrawals
        if (msg.value == 0) {
            players[msg.sender].pendingWithdrawals -= raffles[_raffleId].price;
        }

        uint nextTicketNumber = raffles[_raffleId].lastTicketNumber + 1;

        raffles[_raffleId].ticketOwner[nextTicketNumber] = msg.sender;
        raffles[_raffleId].playerTicketsNumbers[msg.sender].push(nextTicketNumber);
        raffles[_raffleId].lastTicketNumber = nextTicketNumber;

        //Add raffle to player's raffles list
        players[msg.sender].raffles.push(_raffleId);

    }

    //This function has to be called manually by one of the owners
    //once they know lifespan has expired. It's impossible to make the contract to call
    //this function itself. Only possible making use of external API as:
    //Ethereum Alarm Clock - http://www.ethereum-alarm-clock.com/
    //They'll call the function for you when scheduled.
    function getWinner(bytes32 _raffleId)
        external isOwner(msg.sender)
        returns(uint ticketNumber, address playerAddress, bytes32 name)
    {
        //Check the Raffle exists, playing time has expired but there has not finished
        require(playingTimeHasExpired(_raffleId));

        ticketNumber = getWinnerNumber(_raffleId);

        (playerAddress, name) = getWinnerPlayer(_raffleId, ticketNumber);

        finishRaffle(_raffleId, ticketNumber, playerAddress);

        givePrizeToWinner(_raffleId, playerAddress);

    }


    //Is not possible to get a random number in a deterministic network, so this way
    //is not safe. Only way is to call to an external API Oracle to calculate it.
    function getWinnerNumber(bytes32 _raffleId)
        private view returns(uint number)
    {
        //It's not a safe way, blockhash can be changed by miner in order to make
        //its ticket number winner
        number = uint(block.blockhash(block.number - 1))%raffles[_raffleId].lastTicketNumber + 1;
    }


    function getWinnerPlayer(bytes32 _raffleId, uint _ticketNumber)
        private view returns(address player, bytes32 name)
    {
        player = ownerByTicket(_raffleId, _ticketNumber);
        name = players[player].name;
    }


    function finishRaffle(bytes32 _raffleId, uint _ticketNumber, address _playerAddress)
        internal
    {
        raffles[_raffleId].winnerTicket = _ticketNumber;
        raffles[_raffleId].winnerPlayer = _playerAddress;
        raffles[_raffleId].finished = true;
    }

    function givePrizeToWinner(bytes32 _raffleId, address _playerAddress)
        internal
    {
        heldBalance += raffles[_raffleId].lastTicketNumber * raffles[_raffleId].price;
        players[_playerAddress].pendingWithdrawals = raffles[_raffleId].lastTicketNumber * raffles[_raffleId].price;
    }

    //Explain withdraw pattern
    function playerWithdraw(uint _amount)
        external
    {
        require(hasEnoughFunds(msg.sender, _amount));

        // Remember to subtract the amount before
        // sending to prevent re-entrancy attacks
        players[msg.sender].pendingWithdrawals -= _amount;

        heldBalance -= _amount;

        msg.sender.transfer(_amount);
    }

    function ownerWithdraw(uint _amount)
        external isOriginalOwner
    {
        //Check if there is enough available balance because maybe some players haven't
        //withdrawn their prizes
        require(hasEnoughAvailableBalance(_amount));

        originalOwner.transfer(_amount);
    }

}

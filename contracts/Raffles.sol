pragma solidity ^0.4.17;

import "./Players.sol";
import "./Ownership.sol";


contract Raffles is Players, Ownership {

    //Also used as nonce
    uint public length = 0;

    struct Raffle {
        bytes32 id;
        bytes32 next;
        bool exists;
        bool finished;
        uint price; //10000000000000000 Wei are 0.01 Eth, currently around 10$
        uint endsAt;

        uint lastTicketNumber;
        uint winnerTicket;

        mapping (uint => address) ticketOwner;
        mapping (address => uint[]) playerTicketsNumbers;
    }

    //Linked list of Raffle
    bytes32 public head;
    mapping (bytes32 => Raffle) public raffles;


    function isActiveRaffle(bytes32 _raffleId) public view returns(bool active) {
        active = (raffles[_raffleId].exists) && (raffles[_raffleId].endsAt >= now);
    }

    function isBettingRafflePrice(bytes32 _raffleId)
        public view returns(bool rightPrice)
    {
        rightPrice = (msg.value == raffles[_raffleId].price);
    }


    function create(uint _price, uint _lifespan) public returns(bool){
        uint memory raffleEnds = now + _lifespan;

        Raffle memory raffle = Raffle(0,head,true,false,_price,raffleEnds,0,0);

        bytes32 id = keccak256(raffle.price,raffle.lifespan,now,length);
        raffles[id] = raffle;
        raffle = raffles[id];
        raffle.id = id;

        head = id;
        length = length + 1;
    }

    //Struct autogenerated Getter() doesn't retrieve mappings,
    //so I have to create special getters
    function ownerByTicket(bytes32 _raffleAddress, uint _ticketNumber)
        public view returns(address owner)
    {
        owner = raffles[_raffleAddress].ticketOwner[_ticketNumber];
    }

    //Struct autogenerated Getter() doesn't retrieve mappings,
    //so I have to create special getters
    //ONLY EXTERNAL FUNCTIONS can return a dynamic array
    function ticketsByOwner(bytes32 _raffleAddress, address _ownerAddress)
        external view returns(uint[] tickets)
    {
        tickets = raffles[_raffleAddress].playerTicketsNumbers[_ownerAddress];
    }


    function play(bytes32 _raffleId) public payable {
        //Check the Player exists
        require(isRegistered(msg.sender));

        //Check the Raffle exists and is not finished
        require(isActiveRaffle(_raffleId));

        require(isBettingRafflePrice(_raffleId));

        uint nextTicketNumber = raffles[_raffleId].lastTicketNumber + 1;

        raffles[_raffleId].ticketOwner[nextTicketNumber] = msg.sender;
        raffles[_raffleId].playerTicketsNumbers[msg.sender].push(nextTicketNumber);
        raffles[_raffleId].lastTicketNumber = nextTicketNumber;

        //Add raffle to player's raffles list
        players[msg.sender].raffles.push(_raffleId);

    }

    function getWinnerPlayer() private returns(address winnerPlayer) {

    }

    function getWinnerNumber(bytes32 _raffleId)
        external isOwner(msg.sender) returns(uint number){
        //Check that only an owner is able to finish the raffle

        Raffle memory raffle = raffles[_raffleId];

        number = uint(block.blockhash(block.number - 1))%raffle.lastTicketNumber + 1;


    }



    function withdrawPrize() external {

    }


    //    function destroy(uint _index) private{
//
//    }

}
